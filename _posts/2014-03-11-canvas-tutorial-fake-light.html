---
layout: post
title:  "Canvas Tutorial Fake Light"
date:   2014-03-11
categories: javascript, canvas
---

<style>
	canvas{
		max-width: 640px !important;
	}
</style>

<h2>Introduction</h2>
<p data-height="300" data-theme-id="4918" data-slug-hash="qBjCH" data-default-tab="result" class='codepen'>See the Pen <a href='http://codepen.io/ilovepixel/pen/qBjCH'>Fake 2D Light</a> by Felipe Alfonso (<a href='http://codepen.io/ilovepixel'>@ilovepixel</a>) on <a href='http://codepen.io'>CodePen</a>.</p>
<script async src="//codepen.io/assets/embed/ei.js"></script>
<p style ='margin-top:20px;'>I was very surprised when I saw this works on <a href="http://codepen.io/ilovepixel/pen/qBjCH">CodePen</a>.</p>
<p>My biggest interest is how codes work on this work. Why I look this as if it is light in the dark room.</p>
<p>I read the codes, I put the blog for it not to forget.</p>

<h2>Define the space on canvas</h2>

<div class="wrapper"><canvas id="canvas1" width="640", height="480"></canvas></div>
<script>
(function(){
	var canvas1 = document.getElementById('canvas1');
	var ctx1    = canvas1.getContext("2d");
	var tile   = { x: 40, y: 40 };

	// set the space as multiple array.
	var map     = [
	                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
	                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
	                [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
	                [1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1],
	                [1,0,0,0,0,1,1,0,1,0,0,0,1,0,0,1],
	                [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
	                [1,0,1,1,1,0,0,1,1,0,0,1,0,0,0,1],
	                [1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1],
	                [1,0,1,1,0,0,0,0,1,0,0,0,0,0,0,1],
	                [1,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1],
	                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
	                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                ];

    function draw(){
    	ctx1.save();
    	ctx1.fillStyle = "rgb(0, 0, 0)";
    	ctx1.fillRect( 0, 0, canvas1.width, canvas1.height );

    	ctx1.fillStyle="rgb(90,90,90)";
        for(var y=0;y<map.length;y++)
        {
          for(var x=0;x<map[y].length;x++)
          {
            if(map[y][x]!=0)
            {
              ctx1.fillRect(x*tile.x,y*tile.y,tile.x,tile.y);
            } 
          }
        }
    };

    draw();

})();
</script>

<p></p>
{% highlight javascript %}
var canvas1 = document.getElementById('canvas1');
var ctx1    = canvas1.getContext("2d");
var tile   = { x: 20, y: 20 };

// set the space as multiple array.
var map     = [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
                [1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1],
                [1,0,0,0,0,1,1,0,1,0,0,0,1,0,0,1],
                [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
                [1,0,1,1,1,0,0,1,1,0,0,1,0,0,0,1],
                [1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1],
                [1,0,1,1,0,0,0,0,1,0,0,0,0,0,0,1],
                [1,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ];

function draw(){
	ctx1.save();
	ctx1.fillStyle = "rgb(0, 0, 0)";
	ctx1.fillRect( 0, 0, canvas1.width, canvas1.height );

	ctx1.fillStyle="rgb(90,90,90)";
    for(var y=0;y<map.length;y++)
    {
      for(var x=0;x<map[y].length;x++)
      {
        if(map[y][x]!=0)
        {
          ctx1.fillRect(x*tile.x,y*tile.y,tile.x,tile.y);
        } 
      }
    }
};

draw();
{% endhighlight %}


<p>
  The walls on canvs are recognized as 1. The roads are recognized as 0.
</p>


<h2>Check if the current position is over the wall or not.</h2>
{% highlight javascript %}
function pointOverTile( x, y ){
  if(x>0 && x<canvas.width && y>0 && y<canvas.height)
  {
    var x2 = Math.floor(x/tile.x);
    var y2 = Math.floor(y/tile.y);
    if(map[y2] && map[y2][x2])
    {
      if(map[y2][x2]!=0)
      {
        x2=y2=null;
        return true;
      }
    }
    else return false;
  }
  else return false;
}
{% endhighlight %}


<h2>Draw Light</h2>
<div class="wrapper"><canvas id="c2" width="640", height="480"></canvas></div>
<script>
  (function(){
    var canvas = document.getElementById("c2"),
      ctx = canvas.getContext("2d"),
      tile = {
        x:40, //width tile size
        y:40 //height tile size
      },
      mouse={
        x: canvas.width / 2,
        y: canvas.height / 2 - 50,
      },
      Point=function(x,y)
      {
        this.x = x || 0;
        this.y = y || 0;
      },
      map = [
              [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
              [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
              [1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
              [1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1],
              [1,0,0,0,0,1,1,0,0,0,0,0,1,0,0,1],
              [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
              [1,0,1,1,1,0,0,1,0,0,0,1,0,0,0,1],
              [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1],
              [1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1],
              [1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1],
              [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
              [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ];

    function drawPointX2(x,y,color)
    {
      var oc = ctx.fillStyle;
      ctx.fillStyle = color;
      ctx.fillRect(x-1,y-1,2,2);
      ctx.fillStyle = oc;
      oc=null;
    }            

    function pointOverTile(x,y)
    {
        if(x>0 && x<canvas.width && y>0 && y<canvas.height)
        {
          var x2 = Math.floor(x/tile.x);
          var y2 = Math.floor(y/tile.y);
          if(map[y2] && map[y2][x2])
          {
            if(map[y2][x2]!=0)
            {
              x2=y2=null;
              return true;
            }
          }
          else return false;
        }
        else return false;
    }

    function drawPolygon(verts,color){
      if(verts.length<3) return;
      ctx.beginPath();
      ctx.fillStyle=color;
      ctx.moveTo(verts[0].x,verts[0]);
      for(var i=1;i<verts.length;i++)
      {
        var v = verts[i];
        if(v) ctx.lineTo(v.x,v.y);
        v=null;
      }
      ctx.fill();
      ctx.closePath();
    }

    function castRay(ox,oy,angle,dist) {
      var r = 0;
      var x=y=0;
      var a=angle*(Math.PI/180);
      x = ox+Math.cos(a)*r;
      y = oy+Math.sin(a)*r;
      while(r<=dist)
      {
        x = ox+Math.cos(a)*r;
        y = oy+Math.sin(a)*r;
        if(pointOverTile(x,y))
        {
          
          break;
        }
        r++;
      }
      if(r<150 && pointOverTile(x,y))
      {
        var p = r/150*100;
        var c = parseInt(255-255*p/100);
        drawPointX2(x,y,"rgb("+c+","+c+","+c+")");
        p  = c = null;
      }
      r = a = null;
      return new Point(x,y);
    }

    function drawLight(ox,oy,radius){
      if(pointOverTile(ox,oy)) return;
      var verts = new Array(360);
      for(var i=0;i<359;i++)
      {
        verts[i] = castRay(ox,oy,i,radius);       
      }
      var grd = ctx.createRadialGradient(ox,oy,5,ox,oy,radius/2);
      grd.addColorStop(0,"#fff");
      grd.addColorStop(.5,"transparent");
      grd.addColorStop(1,"transparent");
      ctx.fillStyle = grd;
      drawPolygon(verts,grd);
      grd = verts = null;
    }

    function testdraw(e){
      if(e){
        mouse.x = e.clientX-canvas.offsetLeft;
        mouse.y = e.clientY-canvas.offsetTop + window.scrollY;
      }else{
        mouse.x = canvas.width/2;
        mouse.y = canvas.height/2;
      }
      
      ctx.save();
      ctx.fillStyle="rgb(0,0,0)";
      ctx.fillRect(0,0,canvas.width,canvas.height);

      //Lower light.
      var grd2 = ctx.createRadialGradient(mouse.x,mouse.y,5,mouse.x,mouse.y,canvas.width);
      grd2.addColorStop(0,"#3a3a3a");
      grd2.addColorStop(.8,"transparent");
      ctx.fillStyle=grd2;
      ctx.fillRect(0,0,canvas.width,canvas.height);

      drawLight(mouse.x,mouse.y,canvas.width);

      ctx.fillStyle="rgb(90,90,90)";
        for(var y=0;y<map.length;y++)
        {
          for(var x=0;x<map[y].length;x++)
          {
            if(map[y][x]!=0)
            {
              ctx.fillRect(x*tile.x,y*tile.y,tile.x,tile.y);
            } 
          }
        }

    }

    canvas.addEventListener("mousemove",testdraw,false);


    testdraw();

  })();



</script>
<p></p>

{% highlight javascript %}
function drawPointX2(x,y,color){
  var oc = ctx.fillStyle;
  ctx.fillStyle = color;
  ctx.fillRect(x-1,y-1,2,2);
  ctx.fillStyle = oc;
  oc=null;
}            

function drawPolygon(verts,color){
  if(verts.length<3) return;
  ctx.beginPath();
  ctx.fillStyle=color;
  ctx.moveTo(verts[0].x,verts[0]);
  for(var i=1;i<verts.length;i++){
    var v = verts[i];
    if(v) ctx.lineTo(v.x,v.y);
    v=null;
  }
  ctx.fill();
  ctx.closePath();
}

function castRay(ox,oy,angle,dist) {
  var r = 0;
  var x=y=0;
  var a=angle*(Math.PI/180);
  x = ox+Math.cos(a)*r;
  y = oy+Math.sin(a)*r;
  while(r<=dist){
    x = ox+Math.cos(a)*r;
    y = oy+Math.sin(a)*r;
    if(pointOverTile(x,y)){
      
      break;
    }
    r++;
  }
  if(r<150 && pointOverTile(x,y)){
    var p = r/150*100;
    var c = parseInt(255-255*p/100);
    drawPointX2(x,y,"rgb("+c+","+c+","+c+")");
    p  = c = null;
  }
  r = a = null;
  return new Point(x,y);
}

function drawLight(ox,oy,radius){
  if(pointOverTile(ox,oy)) return;
  var verts = new Array(360);
  for(var i=0;i<359;i++){
    verts[i] = castRay(ox,oy,i,radius);       
  }
  var grd = ctx.createRadialGradient(ox,oy,5,ox,oy,radius/2);
  grd.addColorStop(0,"#fff");
  grd.addColorStop(.5,"transparent");
  grd.addColorStop(1,"transparent");
  ctx.fillStyle = grd;
  drawPolygon(verts,grd);
  grd = verts = null;
}
{% endhighlight %}

